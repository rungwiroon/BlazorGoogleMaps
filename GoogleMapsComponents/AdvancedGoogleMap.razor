@using GoogleMapsComponents.Maps
@using Microsoft.JSInterop
@implements IAsyncDisposable

<GoogleMap @ref="@MapRef" Id="@Id" Height="@Height" Options="@Options" OnAfterInit="@AfterInit" CssClass="@CssClass" />

@if (MapRef?.InteropObject is not null)
{
    <CascadingValue Name="Map" Value="@this" IsFixed="true">
        @ChildContent
    </CascadingValue>
}

@code {
    // Due to us wrapping the normal map, keep this public to still be able to access the interop.
    public GoogleMap? MapRef;
    
    // Expose this for simplicity.
    public Map? InteropObject => MapRef?.InteropObject;
    
    internal Guid? MapId => MapRef?.InteropObject.Guid;
    
    public int ComponentCount => _mapComponents.Count;
    public IEnumerable<IMapComponent> Components => _mapComponents.Select(x => x.Value);
    private readonly Dictionary<Guid, IMapComponent> _mapComponents = [];

    internal DotNetObjectReference<AdvancedGoogleMap>? CallbackRef;
    
    [Parameter]
    public string? Id { get; set; }

    [Parameter]
    public MapOptions? Options { get; set; }

    [Parameter]
    public EventCallback OnAfterInit { get; set; }
    
    [Parameter]
    public EventCallback OnMarkersChanged { get; set; }

    [Parameter]
    public EventCallback OnPolygonsChanged { get; set; }


    [Parameter]
    public string? CssClass { get; set; }

    [Parameter]
    public string? Height { get; set; }
    
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    protected override void OnInitialized()
    {
        CallbackRef = DotNetObjectReference.Create(this);
        base.OnInitialized();
    }

    private async Task AfterInit()
    {
        await OnAfterInit.InvokeAsync();
    }
    
    [JSInvokable]
    public async Task OnMarkerClicked(Guid markerId)
    {
        if (_mapComponents.TryGetValue(markerId, out var component) && component is MarkerComponent markerComponent)
        {
            await markerComponent.MarkerClicked();
        }
    }

    [JSInvokable]
    public async Task OnMarkerDrag(Guid markerId, LatLngLiteral position)
    {
        if (_mapComponents.TryGetValue(markerId, out var component) && component is MarkerComponent markerComponent)
        {
            await markerComponent.MarkerDragged(position);
        }
    }

    [JSInvokable]
    public async Task OnPolygonClicked(Guid polygonId)
    {
        if (_mapComponents.TryGetValue(polygonId, out var component) && component is PolygonComponent polygonComponent)
        {
            await polygonComponent.Click();
        }
    }

    [JSInvokable]
    public async Task OnPolygonPathChange(Guid polygonId, List<List<LatLngLiteral>> paths)
    {
        if (_mapComponents.TryGetValue(polygonId, out var component) && component is PolygonComponent polygonComponent)
        {
            await polygonComponent.PathChanged(paths);
        }
    }
    
    internal void RegisterComponent(IMapComponent component)
    {
        _mapComponents.TryAdd(component.Guid, component);
        //TODO: New callback.
        OnMarkersChanged.InvokeAsync();
    }
    
    internal void UnregisterComponent(IMapComponent component)
    {
        _mapComponents.Remove(component.Guid);
        OnMarkersChanged.InvokeAsync();
    }

    public async ValueTask DisposeAsync()
    {
        // Mark components as disposed, since they will be removed by disposing the MapRef.
        foreach (var component in _mapComponents)
        {
            component.Value.SetDisposed();
        }

        if (MapRef != null)
        {
            await MapRef.DisposeAsync();
        }

        CallbackRef?.Dispose();
    }

}