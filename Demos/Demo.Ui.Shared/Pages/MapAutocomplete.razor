@page "/mapAutocomplete"
@using GoogleMapsComponents
@using GoogleMapsComponents.Maps
@using GoogleMapsComponents.Maps.Places


@*
    The code for this sample was taken from below on 09/02/2020:
    https://developers-dot-devsite-v2-prod.appspot.com/maps/documentation/javascript/examples/places-autocomplete
*@

<h1>Google Map Autocomplete</h1>

<div style="margin-bottom: 10px;">
    <gmp-place-autocomplete @ref="this.placeAutocompleteElement" id="searchBox"></gmp-place-autocomplete>
    <button @onclick="Search">Search</button>
</div>

<div>
    <p style="font-weight: bold; font-size: 1.2em">@this.message</p>
</div>

<GoogleMap @ref="@(this.map1)" Id="map1" Options="@(this.mapOptions)" OnAfterInit="async () => await OnAfterMapInit()"></GoogleMap>

@functions {
    private readonly Stack<AdvancedMarkerElement> markers = new Stack<AdvancedMarkerElement>();

    private GoogleMap map1;
    private MapOptions mapOptions;
    private PlaceAutocompleteElement placeAutocomplete;
    private PlaceService placeSearchService;
    private Geocoder geocoder;

    private string message;

    private ElementReference placeAutocompleteElement;
    private PlacePrediction? lastPrediction;
    private string? lastQuery;

    protected override void OnInitialized()
    {
        this.mapOptions = new MapOptions
        {
            Zoom = 13,
            Center = new LatLngLiteral(-33.8688, 151.2195),
            MapTypeId = MapTypeId.Roadmap
        };
    }

    private async Task OnAfterMapInit()
    {

        this.placeAutocomplete = await PlaceAutocompleteElement.FromElementAsync(this.map1.JsRuntime, this.placeAutocompleteElement);
        this.placeSearchService = await PlaceService.CreateAsync(this.map1.JsRuntime, new PlaceOptions
        {
            Id = System.Guid.NewGuid().ToString()
        });
        this.geocoder = await Geocoder.CreateAsync(this.map1.JsRuntime);

        await this.placeAutocomplete.AddListener<PlaceAutocompleteElementSelectEvent>("gmp-select", async (selectEvent) =>
        {
            var prediction = selectEvent.PlacePrediction;
            this.lastPrediction = prediction;
            if (string.IsNullOrWhiteSpace(prediction?.PlaceId))
            {
                this.message = "No results available";
                this.StateHasChanged();
                return;
            }

            this.lastQuery = prediction.Text ?? prediction.MainText;
            await ApplyPredictionAsync(prediction);
        });
    }

    private async Task Search()
    {
        if (this.lastPrediction == null || string.IsNullOrWhiteSpace(this.lastPrediction.PlaceId))
        {
            var textQuery = await this.placeAutocomplete.GetInputValueAsync();
            if (string.IsNullOrWhiteSpace(textQuery))
            {
                this.message = "Please select a place from the list first.";
                this.StateHasChanged();
                return;
            }

            this.lastQuery = textQuery;
            var response = await this.placeSearchService.SearchByText(new SearchByTextRequest
            {
                TextQuery = textQuery,
                Fields = new[] { "displayName", "location" }
            });

            var place = response.Places != null && response.Places.Length > 0 ? response.Places[0] : null;
            if (place == null)
            {
                this.message = "No results available";
                this.StateHasChanged();
                return;
            }

            await ApplyPlaceAsync(place);
            return;
        }

        this.lastQuery = this.lastPrediction.Text ?? this.lastPrediction.MainText;
        await ApplyPredictionAsync(this.lastPrediction);
    }

    private async Task ApplyPredictionAsync(PlacePrediction prediction)
    {
        var placeService = await PlaceService.CreateAsync(this.map1.JsRuntime, new PlaceOptions
        {
            Id = prediction.PlaceId!
        });

        var place = await placeService.FetchFields(new FetchFieldsRequest
        {
            Fields = new[] { "displayName", "location" }
        });

        if (place?.Location == null)
        {
            this.message = "No results available";
        }
        else
        {
            await ApplyPlaceAsync(place);
        }

        this.StateHasChanged();
    }

    private async Task ApplyPlaceAsync(GoogleMapsComponents.Maps.Places.Place place)
    {
        if (place.Location == null && !string.IsNullOrWhiteSpace(place.Id))
        {
            var placeService = await PlaceService.CreateAsync(this.map1.JsRuntime, new PlaceOptions
            {
                Id = place.Id
            });

            place = await placeService.FetchFields(new FetchFieldsRequest
            {
                Fields = new[] { "displayName", "location" }
            });
        }

        if (place.Location == null)
        {
            if (!string.IsNullOrWhiteSpace(this.lastQuery) && this.geocoder != null)
            {
                var geoResponse = await this.geocoder.Geocode(new GeocoderRequest
                {
                    Address = this.lastQuery
                });

                if (geoResponse.Status == GeocoderStatus.Ok && geoResponse.Results.Length > 0)
                {
                    var geoLocation = geoResponse.Results[0].Geometry.Location;
                    await this.map1.InteropObject.SetCenter(geoLocation);
                    await this.map1.InteropObject.SetZoom(13);

                    await ClearMarkersAsync();
                    var geoMarker = await AdvancedMarkerElement.CreateAsync(this.map1.JsRuntime, new AdvancedMarkerElementOptions
                    {
                        Position = geoLocation,
                        Map = this.map1.InteropObject,
                        Title = this.lastQuery,
                        Content = new PinElement()
                    });

                    this.markers.Push(geoMarker);
                    this.message = "Displaying result for " + this.lastQuery;
                    return;
                }
            }

            this.message = "No results available";
            return;
        }

        var location = place.Location.Value;
        await this.map1.InteropObject.SetCenter(location);
        await this.map1.InteropObject.SetZoom(13);

        await ClearMarkersAsync();
        var marker = await AdvancedMarkerElement.CreateAsync(this.map1.JsRuntime, new AdvancedMarkerElementOptions
        {
            Position = location,
            Map = this.map1.InteropObject,
            Title = place.DisplayName,
            Content = new PinElement()
        });

        this.markers.Push(marker);

        this.message = "Displaying result for " + (place.DisplayName ?? "Selected place");
    }

    private async Task ClearMarkersAsync()
    {
        while (this.markers.Count > 0)
        {
            var marker = this.markers.Pop();
            await marker.SetMap(null);
        }
    }
}
